package ArsenyVekshin.lab6.client.utils.builder;

import ArsenyVekshin.lab6.client.utils.validators.*;
import ArsenyVekshin.lab6.common.collectionElems.data.Entity;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.function.Supplier;

public class ObjTree {

    private String fieldName;
    private boolean isMayNull = true;
    private boolean isAutoGenerated = false;
    private boolean isEnum = false;
    private boolean isPrimitive = false;

    private Class<?> fieldType;
    public Supplier<? extends Entity> constructor;

    private ArrayList<ObjTree> fields = new ArrayList<>();

    private ArrayList<Validatable> validators = new ArrayList<>();
    private HashMap<String, Enum<?>> enumContains = new HashMap<>();


    /**
     * Create field note (with param importing)
     * @param fieldName field name
     * @param fieldType field type
     */
    public <T> ObjTree(String fieldName, Class<T> fieldType){
        this.fieldName = fieldName;
        this.fieldType = fieldType;
        isPrimitive = Converter.checkForPrimitive(fieldType);

        if(fieldType.isEnum()){
            isEnum = true;
            for(T i : fieldType.getEnumConstants())
                enumContains.put(i.toString(), (Enum<?>) i);
        }

        if(!isPrimitive) {
            try {
                Entity obj = (Entity) fieldType.getConstructor().newInstance();
                this.constructor = obj.getConstructorReference();
                for(Field field : fieldType.getDeclaredFields()) {
                    this.fields.add(new ObjTree(field.getName(), field.getType(), getValidators(field)));
                }
            } catch (Exception e) {
                System.out.println(e.getMessage());//e.printStackTrace();
            }
        }
    }

    /**
     * Create field note (with param importing) with validators
     * @param name field name
     * @param type field type
     * @param validators field validators
     */
    public ObjTree(String name, Class<?> type, ArrayList<Validatable> validators) {
        this(name, type);
        this.validators = validators;
        for(Validatable validatable : validators) {
            if(validatable instanceof NotNullValidator) {
                isMayNull = false;
            }
            if(validatable instanceof AutoGeneratedValidator) {
                isAutoGenerated = true;
            }
        }
    }

    /**
     * get field validators from annotation
     * @param field field
     * @return validators array
     * @throws NoSuchMethodException
     * @throws InstantiationException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    private ArrayList<Validatable> getValidators(Field field) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        ArrayList<Validatable> validatables = new ArrayList<>();
        Annotation[] annotations = field.getAnnotations();

        for(Annotation annotation : annotations) {
            ValidatableAnnotation validatableAnnotation = annotation.annotationType().getAnnotation(ValidatableAnnotation.class);
            if(validatableAnnotation != null) {
                Validatable validatable = validatableAnnotation.validator().getConstructor().newInstance();
                if(annotation instanceof GreaterThan) {
                    validatable = ((ValidatableWithArg)validatable).getInstance(((GreaterThan)annotation).value());
                } else {
                    validatable = validatable.getInstance();
                }
                validatables.add(validatable);
            }
        }
        return validatables;
    }

    public <T> ObjTree(Class<T> type) {
        this(type.getName(), type);
    }

    /**
     * Debug object tree print
     * @param tree tree to print
     * @param tab tab size
     */
    public static void print(ObjTree tree, String tab) {
        System.out.println(tab + tree.fieldName + "   " +
                " (null=" + tree.isMayNull +
                ", agen=" + tree.isAutoGenerated +
                ", enum=" + tree.isEnum +
                ", prim=" + tree.isPrimitive + ")"
        );
        if(!tree.isPrimitive) {
            for(ObjTree x : tree.fields) {
                ObjTree.print(x, tab + "  ");
            }
        }
    }

    /**
     * get field constructor
     * @return field constructor
     */
    public Supplier<? extends Entity> getConstructor() {
        return constructor;
    }

    /**
     * get fields on object
     * @return fields list
     */
    public ArrayList<ObjTree> getFields() {
        return fields;
    }

    /**
     * get all possible enum-values
     * @return map of key - value
     */
    public HashMap<String, Enum<?>> getEnumContains() {
        return enumContains;
    }

    /**
     * get validators array for this field
     * @return validator
     */
    public ArrayList<Validatable> getValidators() {
        return validators;
    }

    public boolean isEnum() {
        return isEnum;
    }

    public boolean isPrimitive() {
        return isPrimitive;
    }

    public boolean isAutoGenerated() {
        return isAutoGenerated;
    }

    public boolean isMayNull() {
        return isMayNull;
    }

    public Class<?> getFieldType() {
        return fieldType;
    }

    public String getFieldName() {
        return fieldName;
    }

}
